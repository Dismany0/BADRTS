package com.game.game.Objects;

import com.game.game.AStar.node;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.PriorityQueue;

import com.game.game.*;
import com.game.engine.*;

//The GUnit, or the game unit, is likely the most interesting class in the game. It is the base of any entity that is capable of walking around, dealing damage, or die
//It comes with a lot of variables, including maximum health, size, attack range, leash range, and more.
public abstract class GUnit extends GObject {
    protected int left = 0;
    protected int maxHealth, health;
    protected int speed;
    protected int size;
    protected int armour; 
    //The attackrange determines how far away you can strike a target, while the leash range determines how far away the target can go before the
    //gunit loses interest in chasing. Vision range was intended to be the maximum distance the enemy could be spotted, but the idea was eventually scrapped
    //and added to leash range
    protected int attackRange, leashRange, visionRange;

    //For animations
    protected boolean walking = false;
    //0 is left, 1 is right
    protected int direction = 0;

    //These are also for animations, as well as attacking. Attackwindup tells me what frame of the attack they are on
    protected int attackWindUp = 0;
    protected boolean attacking = false;
    protected int attackCycles = 0;
    //Attack moving generally refers to moving to a location, but if anything walks into your attackrange, you stop to attack it instead
    //My attackmove attacks the target closest to this character if it spots something in its attackrange.
    protected boolean attackMoved = false;

//The target is the object it is currently attacking
    protected GObject target;

    protected LinkedList<Integer> Path;
    protected int[] OccupiedTiles;
    protected int CenterTile;
    protected int goal;

    //Distance, Heuristic, and AStar work together to perform individual pathfinding. When pathfinding as a group with many units, upwards of hundreds
    //AStar's impressive speed is still going to feel slow just because of the massive amount of numbers
    public double distance(int tile, GameManager gm){
        int x1 = CenterTile % gm.getLevelW();
        int y1 = CenterTile / gm.getLevelW();
        int x2 = tile % gm.getLevelW();
        int y2 = tile / gm.getLevelW();

        return Math.sqrt(Math.pow((x1 - x2),2) + Math.pow((y1 - y2),2));
    }

//That is why genPath is used instead for those situations. The map is generated a single time to show every possible path to take to a single tile.
//Instead of individually pathfinding each of the hundreds of units, you pathfind the map, and the units simply follow the map.
//GenPath follows the flowfield map generated by the main game manager, and generates a path to walk.
    public void genPath(GameManager gm){
        Path.clear();
        int SearchTile = CenterTile;
        if(gm.getFlowField() == null){
            return;
        }
        while(gm.getFlowField()[SearchTile] != 0){
            
            if(SearchTile == smallestNode(gm, SearchTile)) {
                break;
            }
            SearchTile = smallestNode(gm, SearchTile);
            Path.add(SearchTile);
        }
        Path.add(SearchTile);
        goal = SearchTile;
    }
    //Abstract attack, while GUnit isn't really a unit, all its descendants are, and should be able to attack
    public abstract void attack(GameManager gm, GObject target);

    //This is the algorithm that is called to search for a unit. It searches within its leash range to try to locate a unit. When a unit is found, 
    //It approaches it by switching to astar pathfinding. When it is within attack range, it begins attacking.
    public void searchTarget(GameManager gm){
        ArrayList<GUnit>[] unitMap = gm.getEUnitMap();
        if(owner == 1){
            unitMap = gm.getUnitMap();
        }
        
        //finds the closest target within its leash range. Selects it as the target
        int tx = CenterTile % gm.getLevelW();
        int ty = CenterTile / gm.getLevelW();
        int minX = 1000;
        int minY = 1000;
        boolean found = false;
        
        for(int x = -leashRange; x <= leashRange; x++){
            for(int y = -leashRange; y<= leashRange; y++){
                if(tx + x < 0 || ty + y < 0 || tx + x >= gm.getLevelW() || ty + y >= gm.getLevelH()){
                    continue;
                }
                if(x*x + y*y > leashRange *leashRange)
                    continue;
                
                if(unitMap[tx + x + (ty + y) * gm.getLevelW()].size() <= 0){
                    continue;
                }
                found = true;

                if(x*x + y*y < minX*minX + minY*minY){
                    minX = x;
                    minY = y;
                }
            }
        }
        if(found){
            target = (GUnit) unitMap[(tx + minX) + (ty + minY) * gm.getLevelW()].get((int)(unitMap[(tx + minX) + (ty + minY) * gm.getLevelW()].size()* Math.random()));
            // System.out.println(target.x + " " + target.y + " " + target.getTag());
        }

    }

    public void searchTarget(GameManager gm, int tx, int ty){
        ArrayList<GUnit>[] unitMap = gm.getEUnitMap();
        if(owner == 1){
            unitMap = gm.getUnitMap();
        }
        
        //finds the closest target within its leash range. Selects it as the target
        int minX = 1000;
        int minY = 1000;
        boolean found = false;
        
        for(int x = -5; x <= 5; x++){
            for(int y = -5; y<= 5; y++){
                if(tx + x < 0 || ty + y < 0 || tx + x >= gm.getLevelW() || ty + y >= gm.getLevelH()){
                    continue;
                }
                if(x*x + y*y > 5 *5)
                    continue;
                
                if(unitMap[tx + x + (ty + y) * gm.getLevelW()].size() <= 0){
                    continue;
                }
                found = true;

                if(x*x + y*y < minX*minX + minY*minY){
                    minX = x;
                    minY = y;
                }
            }
        }
        if(found){
            target = (GUnit) unitMap[(tx + minX) + (ty + minY) * gm.getLevelW()].get((int)(unitMap[(tx + minX) + (ty + minY) * gm.getLevelW()].size()* Math.random()));
            // System.out.println(target.x + " " + target.y + " " + target.getTag());
        }

    }
    //Simply just moves in a direction to follow the next tile of the path/ The path is really just an arraylist of tiles for the unit to follow.
    //The unit looks at the top of the arraylist to figure out what is the next tile to walk to
    public void walk(GameManager gm){
        int nextTile = Path.getFirst();
        if((gm.getTiles()[nextTile] >= 13 && gm.getTiles()[nextTile] < 26) || (gm.getTiles()[nextTile] >= 52 && gm.getTiles()[nextTile] < 65)){
            astar(gm, CenterTile, goal);
        }

        int goalX = (nextTile % gm.getLevelW()) * GameManager.TILE_SIZE + GameManager.TILE_SIZE / 2;
        int goalY = (nextTile / gm.getLevelW())  * GameManager.TILE_SIZE+ GameManager.TILE_SIZE / 2;
        int CX = x + width/ 2;
        int CY = y + height/ 2;
        if(!Path.isEmpty()){
            
            if(CX == goalX && CY == goalY){
                Path.removeFirst();
            }
                
            if(CX < goalX){
                x++;
                direction = 0;
            }else if (CX > goalX){
                x--;
                direction = 1;
            }
            if(CY < goalY){
                y++;
            }else if (CY > goalY){
                y--;
            }
        }   
    }

    //Find the smallest surrounding node, given one tile
    public int smallestNode(GameManager gm, int Tile){
        int tx = Tile % gm.getLevelW();
        int ty = Tile / gm.getLevelW();
        int min = Tile;

        for(int x = -1; x <= 1; x++){
            for(int y = -1; y <=1; y++){
                if(tx + x < 0 || ty + y < 0 || tx + x >= gm.getLevelW() || ty + y >= gm.getLevelH()){
                    continue;
                }
                if(Math.abs(x) != 0 && Math.abs(y) != 0){
                    if(gm.getFlowField()[min] > (gm.getFlowField()[tx + x + (ty + y) * gm.getLevelW()])){
                        min = tx + x + (ty + y) * gm.getLevelW();
                    }
                }else{
                    if(gm.getFlowField()[min] > gm.getFlowField()[tx + x + (ty + y) * gm.getLevelW()] - 0.1f && gm.getFlowField()[tx + x + (ty + y) * gm.getLevelW()] != 65535){
                        min = tx + x + (ty + y) * gm.getLevelW();
                    }
                }

                
            }
        }
        return min;
    }

    public void update(GameContainer gc, GameManager gm, float dt) {

        if(owner == 0)
        gm.getUnitMap()[CenterTile].add(this);
        else if(owner == 1)
        gm.getEUnitMap()[CenterTile].add(this);

        
        if(target!= null && attacking){
            attack(gm, target);
        }
        else{
            attackWindUp = 0;
        }


        CenterTile = (int) (((x + width / 2) / 16) + ((y + height / 2) / 16) * gm.getLevelW());


        if (x > gm.getLevelW() * GameManager.TILE_SIZE || x < 0 || y > gm.getLevelH() * GameManager.TILE_SIZE
                || y < 0) {
            remove = true;
        }

        if(health <= 0){
            remove = true;
        }

        if (selectStatus != 0)
            

            if (gc.getInput().isButtonDown(MouseEvent.BUTTON3)) {
                attackMoved = false;
                target = null;
                genPath(gm);
            }
            else if (gc.getInput().isKeyDown(KeyEvent.VK_A)) {
                attackMoved = true;
                genPath(gm);
            }
            if(gc.getInput().isKeyDown(KeyEvent.VK_S)){
                attackMoved = false;
                attacking = false;
                target = null;
                walking = false;
                if(!Path.isEmpty()){
                    Path.clear();
                }
            }

        if(!Path.isEmpty() && (gm.getUnitMap()[Path.getFirst()].size() + gm.getEUnitMap()[Path.getFirst()].size()< 2)) {
            walk(gm);
            walking = true;
        }else if (!Path.isEmpty() && (owner == 1 || gm.getAiControl())){
            walk(gm);
            walking = true;
        }else{
            walking = false;
        }
        // else if(!Path.isEmpty()){
        //     astar(gm,CenterTile,goal);
        // }
        
    }

    
    //The health of the units can be seen in debug, along with which side they are on
    public void render(GameContainer gc, GameManager gm, Renderer r) {
        if (gm.getShowHitbox())
        r.fillRect((CenterTile % gm.getLevelW()) * 16, (CenterTile / gm.getLevelW()) * 16, width, height,
                0xff000000);
        if(gm.getShowUnitHealth()){
            r.fillRect(x, y - 8, 16, 1, 0xff000000);
            r.fillRect(x, y - 8,(int)( 16 * ((float)health / (float)maxHealth)), 1, 0xffff2222);

            if(owner == 1){
                r.fillRect(x, y -7, 16, 1, 0xffff0000);
            }
            else{
                r.fillRect(x, y -7, 16, 1, 0xff00ff00);
            }
        }
        if(selectStatus == 1){
            r.setzDepth(2);
            r.drawImage(GameManager.selectRing, x, y);
            r.setzDepth(0);
        }
        

    }
    //Here is the astar algorithm. It is essentially djikstra's algorithm, but with a heuristic, or "guess" thrown in.
    //So the closer to node is to the goal, ignoring all walls and terrain, the more astar will lean towards that direction.
    public void astar(GameManager gm, int start, int goal) {
        if(Path != null)
            Path.clear();
        else{
            return;
        }

        PriorityQueue<node> openSet = new PriorityQueue<node>();
        openSet.add(new node(start, 0));
        HashMap<Integer, Integer> cameFrom = new HashMap<Integer, Integer>();
        HashMap<Integer, Double> costSoFar = new HashMap<Integer, Double>();

        cameFrom.put(start, start);
        costSoFar.put(start, 0.0);

        while (!openSet.isEmpty()) {
            int current = openSet.poll().location;

            if (current == goal) {
                break;
            }
            
            ArrayList<node> neighbours = getNeighbours(gm, current);
            for (node Nnext : neighbours) {
                int next = Nnext.location;
                double cost = costSoFar.get(current) + Nnext.cost;
                
                if (costSoFar.get(next) == null || costSoFar.get(next) > cost) {
                    
                    costSoFar.put(next, cost);
                    double priority = cost + heuristic(gm, next, goal);
                    openSet.add(new node(next, priority));
                    cameFrom.put(next,current);
                }
            }
        }

        if(cameFrom.get(goal) != null){
            int temp = goal;
            this.goal = goal;
            while(temp != start){
                Path.addFirst(temp);
                temp = cameFrom.get(temp);
            }
        }
    }
    public ArrayList<node> getNeighbours(GameManager gm, int current) {
        int cx = current % gm.getLevelW();
        int cy = current / gm.getLevelW();
        ArrayList<node> neighbours = new ArrayList<node>();
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                if (cx + x < 0 || cx + x > gm.getLevelW() || cy + y < 0 || cy + y > gm.getLevelH()
                        || (x == 0 && y == 0)) {
                    continue;
                }
                double cost = 1.0;
                if((gm.getTiles()[(cx+x) + (cy+y) * gm.getLevelW()] >= 13 && gm.getTiles()[(cx+x) + (cy+y) * gm.getLevelW()] < 26) || (gm.getTiles()[(cx+x) + (cy+y) * gm.getLevelW()] >= 52 && gm.getTiles()[(cx+x) + (cy+y) * gm.getLevelW()] < 65)){
                    continue;}
                // }else if(Math.abs(x) == 1 && Math.abs(y) == 1){
                //     cost = Math.sqrt(2.0);
                // }
                neighbours.add(new node((cx + x) + (cy + y) * gm.getLevelW(),cost));
            }
        }

        return neighbours;

        //Here is the heuristic. It is literally just returning the distance between 2 points
    }
    public double heuristic(GameManager gm, int current, int goal) {
        int ax = current % gm.getLevelW();
        int ay = current / gm.getLevelW();
        int bx = goal % gm.getLevelW();
        int by = goal / gm.getLevelW();

        int dx = Math.abs(ax - bx);
        int dy = Math.abs(ay - by);
        // return (dx + dy) + (Math.sqrt(2) - 2) * Math.min(dx, dy);
        return (dx + dy);
    }
    

    /**
     * @return the centerTile
     */
    public int getCenterTile() {
        return CenterTile;
    }

    /**
     * @param centerTile the centerTile to set
     */
    public void setCenterTile(int centerTile) {
        CenterTile = centerTile;
    }

    /**
     * @return the left
     */
    public int getLeft() {
        return left;
    }

    /**
     * @param left the left to set
     */
    public void setLeft(int left) {
        this.left = left;
    }

    /**
     * @return the maxHealth
     */
    public int getMaxHealth() {
        return maxHealth;
    }

    /**
     * @param maxHealth the maxHealth to set
     */
    public void setMaxHealth(int maxHealth) {
        this.maxHealth = maxHealth;
    }

    /**
     * @return the health
     */
    public int getHealth() {
        return health;
    }

    /**
     * @param health the health to set
     */
    public void setHealth(int health) {
        this.health = health;
    }

    /**
     * @return the speed
     */
    public int getSpeed() {
        return speed;
    }

    /**
     * @param speed the speed to set
     */
    public void setSpeed(int speed) {
        this.speed = speed;
    }

    /**
     * @return the size
     */
    public int getSize() {
        return size;
    }

    /**
     * @param size the size to set
     */
    public void setSize(int size) {
        this.size = size;
    }

    /**
     * @return the armour
     */
    public int getArmour() {
        return armour;
    }

    /**
     * @param armour the armour to set
     */
    public void setArmour(int armour) {
        this.armour = armour;
    }

    /**
     * @return the attackRange
     */
    public int getAttackRange() {
        return attackRange;
    }

    /**
     * @param attackRange the attackRange to set
     */
    public void setAttackRange(int attackRange) {
        this.attackRange = attackRange;
    }

    /**
     * @return the leashRange
     */
    public int getLeashRange() {
        return leashRange;
    }

    /**
     * @param leashRange the leashRange to set
     */
    public void setLeashRange(int leashRange) {
        this.leashRange = leashRange;
    }

    /**
     * @return the visionRange
     */
    public int getVisionRange() {
        return visionRange;
    }

    /**
     * @param visionRange the visionRange to set
     */
    public void setVisionRange(int visionRange) {
        this.visionRange = visionRange;
    }

    /**
     * @return the target
     */
    public GObject getTarget() {
        return target;
    }

    /**
     * @param target the target to set
     */
    public void setTarget(GObject target) {
        this.target = target;
    }

    /**
     * @return the path
     */
    public LinkedList<Integer> getPath() {
        return Path;
    }

    /**
     * @param path the path to set
     */
    public void setPath(LinkedList<Integer> path) {
        Path = path;
    }

    /**
     * @return the occupiedTiles
     */
    public int[] getOccupiedTiles() {
        return OccupiedTiles;
    }

    /**
     * @param occupiedTiles the occupiedTiles to set
     */
    public void setOccupiedTiles(int[] occupiedTiles) {
        OccupiedTiles = occupiedTiles;
    }

    /**
     * @return the goal
     */
    public int getGoal() {
        return goal;
    }

    /**
     * @param goal the goal to set
     */
    public void setGoal(int goal) {
        this.goal = goal;
    }

    /**
     * @return the attackWindUp
     */
    public int getAttackWindUp() {
        return attackWindUp;
    }

    /**
     * @param attackWindUp the attackWindUp to set
     */
    public void setAttackWindUp(int attackWindUp) {
        this.attackWindUp = attackWindUp;
    }

    /**
     * @return the attacking
     */
    public boolean isAttacking() {
        return attacking;
    }

    /**
     * @param attacking the attacking to set
     */
    public void setAttacking(boolean attacking) {
        this.attacking = attacking;
    }

    /**
     * @return the attackCycles
     */
    public int getAttackCycles() {
        return attackCycles;
    }

    /**
     * @param attackCycles the attackCycles to set
     */
    public void setAttackCycles(int attackCycles) {
        this.attackCycles = attackCycles;
    }

    /**
     * @return the walking
     */
    public boolean isWalking() {
        return walking;
    }

    /**
     * @param walking the walking to set
     */
    public void setWalking(boolean walking) {
        this.walking = walking;
    }

    /**
     * @return the direction
     */
    public int getDirection() {
        return direction;
    }

    /**
     * @param direction the direction to set
     */
    public void setDirection(int direction) {
        this.direction = direction;
    }

    /**
     * @return the attackMoved
     */
    public boolean isAttackMoved() {
        return attackMoved;
    }

    /**
     * @param attackMoved the attackMoved to set
     */
    public void setAttackMoved(boolean attackMoved) {
        this.attackMoved = attackMoved;
    };
}
